Eureka、Ribbon、Gateway、Zuul、Feign、Hystrix、Config

[参考博客1](https://blog.csdn.net/xunjiushi9717/article/details/91988479)
[参考博客2](https://www.solves.com.cn/it/cxkf/jiagou/2019-10-31/7104.html)
## 注册中心：Eureka

[eureka注册中心讲解](https://blog.csdn.net/sanjiaowuhuan/article/details/104054372)

1. Eureka服务端：也称服务注册中心，同其他服务注册中心一样，支持高可用配置。如果Eureka以集群模式部署，当集群中有分片出现故障时，那么Eureka就转入自我保护模式。它允许在分片故障期间继续提供服务的发现和注册，当故障分片恢复运行时，集群中其他分片会把它们的状态再次同步回来

2. Eureka客户端：主要处理服务的注册与发现。客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，Eureka客户端想注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态

3. Eureka Server的高可用实际上就是将自己作为服务向其他注册中心注册自己，这样就可以形成一组互相注册的服务注册中心，以实现服务清单的互相同步，达到高可用效果

### 服务注册、同步、续约

#### 服务注册

服务提供者在启动的时候会通过发送REST请求的方式将自己注册到Eureka Server上，同时带上了自己服务的一些元数据信息。Eureka Server接收到这个REST请求之后，将元数据信息存储在一个双层结构Map中，其中第一层的key是服务名，第二层的key是具体服务的实例名，因为可能会有多个同名的不同服务（简单的负载均衡）。

#### 服务同步

[高性能注册中心](https://blog.csdn.net/qq_45315910/article/details/102505974)

两个服务提供者分别注册到了两个不同的服务注册中心上，也就是说，它们的信息分别被两个服务注册中心所维护。此时，由于服务注册中心之间因互相注册为服务，当服务提供者发送注册请求到一个服务注册中心时，它会将该请求转发给集群中相连的其他注册中心，从而实现注册中心之间的服务同步。通过服务同步，两个服务提供者的服务信息就可以通过这两台服务注册中心中的任意一台获取到。

#### 服务续约

在注册完服务之后，服务提供者会维护一个心跳用来持续告诉Eureka Server：“我还活着”，以防止Eureka Server的剔除任务将该服务实例从服务列表中排除出去，我们称该操作为服务续约。


## 负载均衡：Ribbon

Ribbon是一个基于HTTP和TCP的客户端负载均衡器。

它可以在通过客户端中配置的ribbonServerList服务端列表去轮询访问以达到服务均衡的作用。当Ribbon和Eureka联合使用时，Ribbon的服务实例清单RibbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务端列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来去定服务端是否已经启动

在客户端负载均衡中，所有客户端节点都维护着自己要访问的服务端清单，而这些服务端的清单来自于服务注册中心（比如Eureka）。在客户端负载均衡中也需要心跳去维护服务端清单的健康性，只是这个步骤需要与服务注册中心配合完成

通过Spring Cloud Ribbon的封装，我们在微服务架构中使用客户端负载均衡调用只需要如下两步：
  
  - 服务提供者只需要启动多个服务实例并且注册到一个注册中心或是多个相关联的服务注册中心
  - 服务消费者直接通过调用被@LoadBalanced注解修饰过的RestTemplate来实现面向服务的接口调用

## 服务间调用：Feign

[Feign 实现1](https://www.jianshu.com/p/ff79509b0962)

[Feign 原理](https://blog.csdn.net/luanlouis/article/details/82821294)

feign是声明式的web service客户端，它让微服务之间的调用变得更简单了，类似controller调用service。

#### Fegin的关键机制是使用了动态代理

1. 首先，对某个接口定义了@FeginClient注解，Fegin就会针对这个接口创建一个动态代理

2. 接着调用接口的时候，本质就是调用Fegin创建的动态代理

3. Fegin的动态代理会根据在接口上的@RequestMapping等注解，来动态构造要请求的服务的地址

4. 针对这个地址，发起请求、解析响应

如下流程图：

（暂无）


## 熔断器（防雪崩利器）：Hystrix [hɪst'rɪks]

一个服务失败，导致整条链路的服务都失败的情形，我们称之为**服务雪崩**。

Hystrix具备服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等强大功能

在微服务架构中，存在着那么多的服务单元，若一个单元出现故障，就很容易因依赖关系而引发故障的蔓延，最终导致整个系统的瘫痪，这样的架构相较传统架构更加不稳定。为了解决这样的问题，产生了断路器等一系列的服务保护机制

在分布式架构中，当某个服务单元发生故障之后，通过断路器的故障监控，向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延

Hystrix使用**舱壁模式**实现线程池的隔离，它会为每一个依赖服务创建一个独立的线程池，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的依赖服务。

### 什么是服务熔断？

服务熔断：当下游的服务因为某种原因突然变得不可用或响应过慢，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。

### 什么是服务降级？

两个场景：

 - 当下游的服务因为某种原因响应过慢，下游服务主动停掉一些不太重要的业务，释放出服务器资源，增加响应速度！
 - 当下游的服务因为某种原因不可用，上游主动调用本地的一些降级逻辑，避免卡顿，迅速返回给用户！

服务降级有很多种降级方式！如开关降级、限流降级、熔断降级!
服务熔断属于降级方式的一种！

### Hystrix 设计目标：

 - 对来自依赖的延迟和故障进行防护和控制——这些依赖通常都是通过网络访问的
 - 阻止故障的连锁反应
 - 快速失败并迅速恢复
 - 回退并优雅降级
 - 提供近实时的监控与告警

### Hystrix 设计原则

 - 防止任何单独的依赖耗尽资源（线程）
 - 过载立即切断并快速失败，防止排队
 - 尽可能提供回退以保护用户免受故障
 - 使用隔离技术（例如隔板，泳道和断路器模式）来限制任何一个依赖的影响
 - 通过近实时的指标，监控和告警，确保故障被及时发现
 - 通过动态修改配置属性，确保故障及时恢复
 - 防止整个依赖客户端执行失败，而不仅仅是网络通信

### Hystrix 实现设计

[实现参考](https://blog.csdn.net/loushuiyifan/article/details/82702522)

 - 使用命令模式将所有对外部服务（或依赖关系）的调用包装在HystrixCommand或HystrixObservableCommand对象中，并将该对象放在单独的线程中执行；
 - 每个依赖都维护着一个线程池（或信号量），线程池被耗尽则拒绝请求（而不是让请求排队）。
 - 记录请求成功，失败，超时和线程拒绝。
 - 服务错误百分比超过了阈值，熔断器开关自动打开，一段时间内停止对该服务的所有请求。
 - 请求失败，被拒绝，超时或熔断时执行降级逻辑。
 - 近实时地监控指标和配置的修改。

#### Hystrix 整个工作流如下：

1. 构造一个 HystrixCommand或HystrixObservableCommand对象，用于封装请求，并在构造方法配置请求被执行需要的参数；
2. 执行命令，Hystrix提供了4种执行命令的方法，后面详述；
3. 判断是否使用缓存响应请求，若启用了缓存，且缓存可用，直接使用缓存响应请求。Hystrix支持请求缓存，但需要用户自定义启动；
4. 判断熔断器是否打开，如果打开，跳到第8步；
5. 判断线程池/队列/信号量是否已满，已满则跳到第8步；
6. 执行HystrixObservableCommand.construct()或HystrixCommand.run()，如果执行失败或者超时，跳到第8步；否则，跳到第9步；
7. 统计熔断器监控指标；
8. 走Fallback备用逻辑
9. 返回请求响应

## 网关：Gateway 和 Zuul

### 什么是网关

网关的角色是作为一个 API 架构，用来保护、增强和控制对于 API 服务的访问。

### 网关的作用/职能

1. 请求接入：作为所有API接口服务的请求的接入点
2. 业务聚合：作为所有后端业务服务的聚合点
3. 中介策略：实现安全、验证、路由、过滤、流量控制等
4. 统一管理：对所有API服务和策略进行管理

spring-cloud-Gateway是spring-cloud的一个子项目。而zuul则是netflix公司的项目，只是spring将zuul集成在spring-cloud中使用而已。
因为zuul2.0连续跳票和zuul1的性能表现不是很理想，所以催生了spring团队开发了Gateway项目。

### Gateway

Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway
旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代ZUUL，
其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。

### Zuul

[参考-Zuul1 和 Zuul2](https://www.cnblogs.com/davidwang456/p/10337441.html)

### Zuul 与 Gateway 的区别

1. 内部实现：

 - gateway对比zuul多依赖了spring-webflux，在spring的支持下，功能更强大，内部实现了限流、负载均衡等，扩展性也更强，但同时也限制了仅适合于Spring Cloud套件
 - zuul则可以扩展至其他微服务框架中，其内部没有实现限流、负载均衡等。

2. 是否支持异步

 - zuul仅支持同步
 - gateway支持异步。理论上gateway则更适合于提高系统吞吐量（但不一定能有更好的性能），最终性能还需要通过严密的压测来决定

3. 框架设计的角度
　　
 - gateway具有更好的扩展性，并且其已经发布了2.0.0的RELESE版本，稳定性也是非常好的

4. 性能
　　
 - WebFlux 模块的名称是 spring-webflux，名称中的 Flux 来源于 Reactor 中的类 Flux。Spring webflux 有一个全新的非堵塞的函数式 Reactive Web 框架，可以用来构建异步的、非堵塞的、事件驱动的服务，在伸缩性方面表现非常好。使用非阻塞API。 Websockets得到支持，并且由于它与Spring紧密集成，所以将会是一个更好的 开发 体验。
 - Zuul 1.x，是一个基于阻塞io的API Gateway。Zuul已经发布了Zuul 2.x，基于Netty，也是非阻塞的，支持长连接，但Spring Cloud暂时还没有整合计划。

　　总的来说，在微服务架构，如果使用了Spring Cloud生态的基础组件，则Spring Cloud Gateway相比而言更加具备优势，单从流式编程+支持异步上就足以让开发者选择它了。
　　对于小型微服务架构或是复杂架构（不仅包括微服务应用还有其他非Spring Cloud服务节点），zuul也是一个不错的选择。

### Filter链 原理
　　
在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。web服务器根据Filter在web.xml文件中的注册顺序，
决定先调用哪个Filter，当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter
方法中，开发人员如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，
如果没有，则调用目标资源。

## 配置中心：Config