## 一、文件

### 1. 参数文件

  定义：记录数据库文件的位置，指定某些初始化参数（这些参数定义了某些内存结构的类型等设置）

  参数的类型分为：静态和动态
   - 静态参数：说明在整个实例的生命周期内都不可以进行更改，好像是只读的
   - 动态参数：在MySQL实例运行时可以修改
	
### 2. 日志文件

#### 错误日志（error log）

  错误日志文件对MySQL的启动、运行、关闭过程进行记录。该文件不仅记录了所有的错误信息，也记录一些警告信息或是正确的信息。默认情况下错误文件的文件名为服务器的主机名。
	
#### 慢查询日志（slow log）

  慢查询日志可帮助DBA定位可能存在问题的SQL语句。从而冲SQL语句的层面优化。
	
#### 查询日志（log）
  
  查询日志记录了所有对MySQL数据库请求的信息，无论请求是否得到了正确的执行。文件为 .log
	
#### 二进制日志（binary log）

  记录了对MySQL数据库执行更改的所有操作，但是不包括　SELECT　和　SHOW　这类操作，因为这类操作对数据本身并没有修改。文件为 name.序列号 
  作用：
  
   - 恢复
   - 复制
   - 审计
  
  binlog_format 的参数值（5.1版本起）：statement、row、mixed
  
  - statement 格式和之前的MySQL版本一样，二进制日志文件记录的是逻辑 SQL 语句
  - row 记录的是表的整行更改情况。
  - mixed 两种混合

  ROW 格式记录了对于整个行更改的信息，即每个地方都记录所有字段的信息，所以会对磁盘空间要求有一定的增加。所以文件的磁盘空间会比 STATEMENT 格式的的文件要大。

#### 中继日志（relay log）
  
  在从服务器上的日志。就是说复制的时候，主服务器任何能够产生数据修改的操作，在写入数据文件的同时，还会把这个语句(也可能是行)记录到二进制日志文件中一份。从服务器就是使用一个用户帐号不断的去连接主服务器，并尝试去读取主服务器上二进制日志中的每一个条目，从服务器将这些挨个的读到从服务器上，在执行之前，先要将这些读到的保存在本地的日志文件中，而后从本地日志文件中读一条执行一条。这个日志文件就叫做中继日志。
  
#### 事务日志

事务日志（InnoDB特有的日志）可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢的刷回到磁盘。目前大多数的存储引擎都是这样实现的，我们通常称之为预写式日志，修改数据需要写两次磁盘。

### 3. 套接字文件

套接字文件可由参数socket控制。一般在 /tmp 目录下，名为 mysql.sock

Linux平台环境下主要有两种连接方式，一种是TCP/IP连接方式，另一种就是socket连接。

在Windows平台下，有name pipe和share memory（不考虑）两种。

TCP/IP连接是网络中用得最多的一种方式。

### 4. pid文件

  MySQL实例启动时，会将自己的进程ID写入一个PID文件中，默认位于数据库目录下，文件名为 主机名.pid
  
### 5. 表结构定义文件

后缀 .frm

## 二、InnoDB存储引擎文件

### 1. 表空间文件

  InnoDB采用将存储的数据按表空间（tablespace）进行存放。独立表空间的命名规则：表名.ibd。
  
  单独的表空间文件仅存储该表的数据、索引和插入缓存BITMAP等信息。其他的信息还是存放在默认的表空间中。

### 2. 重做日志文件

  重做日志文件，记录了对于InnoDB存储引擎的事务日志。
  
  影响重做日志文件的参数属性：
  
  - innodb_log_file_size : 指定每个重做日志文件的大小。
  - innodb_log_files_in_group : 指定了日志文件组中重做日志文件的数量。
  - innodb_mirrored_log_groups ：制定了日志镜像文件组的数量，默认为1.
  - innodb_log_group_home_dir : 指定了日志文件组所在的路径，默认为 ./。

#### 与 二进制日志文件的区别
 
  1. 二进制日志文件会记录所有与MySQL数据库有关的日志文件，包括InnoDB、MyISAM、Heap等其他存储引擎的日志。而InnoDB存储引擎的重做日志只记录有关该存储引擎本身的事务记录。
  2. 二进制日志记录的都是关于一个事务的具体操作，即该日志的逻辑日志。而innodb存储引擎的重做日志文件记录的是关于每个页（page）的更改的物理情况。

## 三、表

[参考博客1：堆表、索引表、索引聚簇表](https://www.cnblogs.com/youngerger/p/8446399.html)

[参考博客2：堆表、索引表](https://www.cnblogs.com/---wunian/p/9204822.html)

（二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表。）

### 1. 索引组织表（index organized table）

![](MySQL原理_files/2.jpg)

  在 InnoDB 存储引擎中，根据主键顺序存放的表，我们叫做索引组织表。索引组织表有一个可变的主B树存储组织。不象普通表(堆组织),数据是无序存储的集合。   
  索引组织表是以主键排序的方式的B树组织结构。
  
### 2. 堆组织表（Heap organized table）

![](MySQL原理_files/1.jpg)

  heap table 就是一般的表，获取表中的数据是按命中率来得到的。没有明确的先后之分，在进行全表扫描的时候，并不是先插入的数据就先获取。数据的存放也是随机的，当然根据可用空闲的空间来决定。
  通常我们建的表默认都是堆表，此类型的表中，数据会以堆的方式进行管理，增加数据时候，会使用段中找到的第一个能放下此数据的自由空间。当从表中删除数据时候，则允许以后的UPDATE和INSERT重用这部分空间，
  它是以一种有些随机的方式使用。
  
  - 堆就是无序数据的集合,索引就是将数据变得有序,在索引中键值有序,数据还是无序的
  - 堆表中,主键索引和普通索引一样的,叶子节点存放的是指向堆表中数据的指针（可以是一个页编号加偏移量）,指向物理地址,没有回表的说法
  - 堆表中,主键和普通索引基本上没区别,和非空的唯一索引没区别
  
  myisam就是用的这个堆表的存储方式,oracle支持堆表,pg只支持堆表
  
### 3. 索引聚簇表（index cluster table）

  聚簇是指：如果一组表有一些共同的列，则将这样一组表存储在相同的数据库块中；聚簇还表示把相关的数据存储在同一个块上。
  利用聚簇，一个块可能包含多个表 的数据。概念上就是如果两个或多个表经常做链接操作，那么可以把需要的数据预先存储在一起。
  聚簇还可以用于单个表，可以按某个列将数据分组存储。
  
### 4. InnoDB 逻辑存储结构

#### 4.1 表空间

  所有数据都被逻辑地存放的空间。由段（segment）、区（extent）、页/块（page/block）、行（row）组成。即逻辑层次结构为 **表空间 > 段 > 区 > 页 > 行**

  段分为数据段（叶子结点）、索引段（非叶子结点，导向作用）、回滚段
  
  区由连续的页组成而成的空间。在任何情况下每个区的大小都为**1MB**。为保证区中页的连续性，InnoDB 存储引擎一次从磁盘申请 4~5 个区。
  在用户启用参数 **innodb_file_per_table** 后，创建的表空间默认大小为 **96KB < 1MB**。那是因为在每段开始时，先用 32 个页大小的碎片页来存放数据，使用完这些碎片页后才是64个连续申请的页。

  页/块在默认的情况下，大小为 16KB。是InnoDB 存储引擎磁盘管理的最小单位。
   
  InnoDB 是面向列数据的，也就是说数据是按照行来进行存放的。每页存放的行记录有硬性定义，每页最多存放 **16KB / 2 - 2000** 行的记录，也就是**7992行**。
  
#### 4.2 InnoDB 行记录格式

在 InnoDB 存储引擎中提供了 **Compact** 与 **Redundant** 两种。

1. **Compact**

  在MySQL5.0中引入的，其设计目标是高效地存储数据。简单的说，就是一个页中的行数据越多，其性能就越高。
  
  其格式：
  
<table>
<tr>
<td>变长字段长度列表（最大不超过2字节）</td>
<td>NULL标志位（1字节，判断是有为NULL）</td>
<td>记录头信息（固定占用5字节）</td>
<td>隐藏列——事务ID列（6字节）</td>
<td>隐藏列——回滚指针列（7字节）</td>
<td>列1数据</td>
<td>列2数据</td>
<td>......</td>
</tr>
</table>

  不管是 CHAR 类型还是 VARCHAR 类型，只要是compact格式，NULL值就不会占用任何存储空间。

2. **Redundant**

  Redundant是MySQL5.0版本之前的InnoDB的行记录方式。

<table>
<tr>
<td>字段长度偏移列表（最大不超过2字节）</td>
<td>记录头信息（固定占用6字节）</td>
<td>隐藏列——事务ID列</td>
<td>隐藏列——回滚指针列</td>
<td>列1数据</td>
<td>列2数据</td>
<td>......</td>
</tr>
</table>

  Redundant行记录格式下，VARCHAR类型的NULL值不占用任何的存储空间，而CHAR类型的NULL值需要占用可能存放的最大值字节数。
  
#### 4.3 InnoDB 数据页结构

1. File Header (文件头) 

  记录页的一些头信息，8个部分组成，共占38字节。

2. Page Header（页头）

  该部分用来记录数据页的状态信息，由14各部分组成，共占用56字节。特别说明，PAGE_INDEX_ID 存储的是数据页中行记录索引的最大值。

3. Infimum 和 Supremun Record

  每个数据页中虚拟的行数据，用来限定行记录的边界。Infimum记录 比该页中的任何记录主键值都要小。Supremum记录是比任何可能大的值还要大的值。
  
4. User Record 和 Free Space

  User Record 是实际存储行记录的内容，**在 InnoDB 中表都是B+数索引组织的**。Free Space 是指空闲空间，在一条记录被删除后，该空间就会被加入到空闲链表中。
  
5. Page Directory

  存放记录的相对位置。

6. File Trailer

  用于检测页是否已经完整地写入磁盘中。只有一个FILE_PAGE_END_LSN 部分，占用8字节。前4字节是该页的 checksum，后4字节和FILE_PAGE_LSN 一样，将两个值进行函数的比较，得出结果。
  
#### 4.4 Named File Formats 机制

  用于解决不同版本下，页结构的兼容性问题。
  
### 5. 约束

  给表提供约束机制，通过增添限制，来保证数据的完整性。[（约束的简述）](http://c.biancheng.net/view/7576.html)
  
  约束的种类：
  - **Primary Key**
  - **Unique Key**    唯一约束与主键约束相似的是它们都可以确保列的唯一性。不同的是，唯一约束在一个表中可有多个，并且设置唯一约束的列允许有空值，但是只能有一个空值。而主键约束在一个表中只能有一个，且不允许有空值。比如，在用户信息表中，为了避免表中用户名重名，可以把用户名设置为唯一约束。
  - **Foreign Key**
  - **Default**
  - **NOT NULL**

特别要注意的是，MySQL不支持传统的 CHECK 约束，但可以通过 ENUM 和 SET 类型来解决部分这样的约束需求。
  
  约束的创建方式：
  - 表建立时就进行约束的定义
  - 利用 ALTER TABLE 命令来进行创建约束

#### 触发器

触发器的作用是在执行 UPDATE、DELETE 和 INSERT 命令前后自动调用SQL命令或存储过程。

创建触发器的命令： CREATE TRIGGER。

#### 外键约束

外键用来保证参照完整性。

一般来说，被引用的表为父表，引用的表称为子表。外键定义时的 ON UPDATE 和 ON DELETE 表示在对父表进行  UPDATE 和 DELETE 操作时，对子表所做的操作，可定义的子表操作有：
- **CASCADE**：表示父表进行 UPDATE 和 DELETE 操作时，对应的子表中的数据也进行 UPDATE 或 DELETE 操作
- **SET NULL**：表示当父表发生 UPDATE 或 DELETE 时，对应的子表中的数据被更新为 NULL。但子表中的列必须允许为NULL。
- **NO ACTION**：表示当父表发生 UPDATE 或 DELETE 时，抛出错误，不允许此类操作发生。
- **RESTRICT（默认）**：表示当父表发生 UPDATE 或 DELETE 时，不允许此类操作发生。


### 6. 视图

在MySQL数据库中，视图（View）是一个命名的虚表，它由一个SQL查询来定义，可以当做表来使用。与正常的持久表（permanent table）不同的是，视图中的数据没有实际的物理存储。

### 7. 分区表

分区的过程是将一个表或索引分解为多个更小、更可管理的部分。MySQL数据库支持的分区类型为水平分区
- 水平分区，指将同一表中的不同行的记录分配到不同的物理文件中。
- 垂直分区，指将同一表中的不同列的记录分配到不同的物理文件中。

当前MySQL支持的分区类型：

- **RANGE分区**：行数据基于属于一个给定连续区间的列值被放入分区。MySQL5.5开始支持 RANGE COLUMNS 的分区。
- **LIST分区**：与 RANGE 分区类型一样，只是 LIST 分区面向的是离散的值。
- **HASH分区**：根据用户自定义的表达式的返回值来进行分区，返回值不能为负数。
- **KEY分区**：根据MySQL数据库中提供的哈希函数来进行分区。

#### 7.1 RANGE 分区

这是最常见的一种分区类型。如下：
```sql
CREATE TABLE t (
	id INT
)ENGINE = INNDB
PARTITION BY RANGE(id)(
PARTITION p0 VALUES LESS THAN(10),
PARTITION p1 VALUES LESS THAN(20)
);
```

主要用于日期列的分区。需要注意的是对于RANGE分区的查询，优化器只能对YEAR()，TO_DAYS()，TO_SECONDS()，UNIX_TIMESTAMP()这类函数进行优化选择。

#### 7.2 LIST 分区

与 RANGE 分区十分的相似，只是分区列的值是离散的，而非连续的。

如果插入的值不在分区的定义中，MySQL数据库同样会抛出异常。

另外，在用 INSERT 插入多行数据的过程中遇到分区未定义的值时，MyISAM 和 InnoDB 存储引擎的处理完全不同。MyISAM 会将之前的行数据都插入，但之后的数据不会被插入。
而 InnoDB 存储引擎将其视为一个事务，因此任何数据都不会插入。

#### 7.3 HASH 分区

HASH 分区的目的是将数据均匀地分布到预先定义的各个分区中，保证各分区的数据量大致都是一样的。

#### 7.4 Key 分区

与 HASH　分区不同之处在于，Key　分区使用　MySQL数据库提供的函数进行分区。

#### 7.5 COLUMNS 分区

这个类型可视为是 RANGE 和 LIST 的一种进化，COLUMNS 分区可以直接使用非整型数据进行分区，分区根据类型直接比较而得，不需要转化为整型。

#### 7.6 子分区

MySQL数据库允许在 RANGE 和 LIST 分区下再进行 HASH 和 KEY 分区。如下
```sql
CREATE TABLE t (a INT, b DATE)ENGINE=INNDB
PARTITION BY RANGE(YEAR(b))
SUBPARTITION BY HASH(TO_DAYS(b))
SUBPARTITIONS 2 (
PARTITION p0 VALUES LESS THAN(1990),
PARTITION p1 VALUES LESS THAN(2000),
PARTITION P2 VALUES LESS THAN MAXVALUE
);
```

MySQL数据库允许对null值进行分区。MySQL数据库的分区总是视 null 值小于任何一个非 null 值，这和 MySQL 数据库中处理 null 值的 order by 操作是一样的。

在 RANGE 分区中 null 值放入的是最小的那个分区，而在 LIST 分区下使用 NULL 值，则必须显示地指出哪个分区中放入 NULL 值，否则会报错。

HASH 和 Key 分区对于 NULL 值的处理是，任何分区的函数都会将含有NULL的记录返回为0值。

#### 7.7 分区与性能

对于 **OLAP（在线分析处理）** 应用，分区可以很好地提高查询地性能，因为OLAP应用大多数查询需要频繁地扫描一张很大的表。如果使用了分区，就只需要扫描相应的分区即可。

对于 **OLTP（在线事务处理）**应用，一般情况下不需要返回很多地数据，大部分都是通过索引返回几条记录，而根据B+树索引可以知道，一张大表，一般的B+树需要2~3次磁盘IO，因此不需要进行分区到多个表空间文件中。