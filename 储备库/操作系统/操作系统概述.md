## 一、计算机系统概述

### （一）基本概念

计算机系统自上而下可大致分为 **硬件、操作系统、应用程序、用户**。操作系统（Operation System， OS）是指控制和管理整个计算机系统的硬件和软件资源，
合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便的接口与环境的程序集合。

### （二）特征
1. **并发**：两个或是多个事件在同一时间间隔内发生。
2. **共享**：系统中的资源可供内存中多个并发执行的的进程共同使用
3. 虚拟：把一个物理上的实体变为若干逻辑上的对应物。
4. 异步：多道程序环境下允许多个程序并发的执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。

### （三）操作系统的发展与分类
1. 手工操作阶段（此阶段无操作系统）
2. 批处理阶段（操作系统开始出现）
3. 分时操作系统
4. 实时操作系统

### （四）操作系统的运行环境

#### 操作系统运行机制
1. 时钟管理
2. 中断机制
3. 原语

	特点：
	- 处于操作系统最低层，是最接近硬件的部分。
	- 这些程序的运行具有原子性，其操作只能一气呵成（主要从系统的安全性和便于管理考虑
	- 这些程序的运行时间都较短，而且调用频繁
	
4. 系统控制的数据结构及处理

#### 中断和异常的概念
中断也称为外中断，指来自CPU执行指令以外的事件的发生，如设备发出的IO结束中断，表示设备的输入输出处理已经完成。

异常也称为内中断、例外或陷入。指源自CPU执行指令内部的事件。如程序的非法操作码、地址越界、算术溢出等。

#### 系统调用

系统调用指的是用户在程序中调用操作系统所提供的一些子功能。

系统调用按照功能大致可分为一下几种：
1. 进程管理。
2. 内存管理。
3. 文件管理。
4. 设备管理。

显然系统调用相关功能涉及到系统资源管理，进程管理之类的操作，对整个系统的影响非常大，因此必定需要使用某些特权指令才能完成。所以系统调用的处理需要由操作系统内核程序负责完成，要运行在核心态。

访管指令：用户程序用来发起系统调用，由用户态切换至核心态
特权指令：在核心态执行的指令

#### 由用户态转向核心态的例子：
1. 系统调用
2. 发生中断
3. 用户程序中产生错误状态
4. 用户程序企图执行一条特权指令

## 二、进程管理

### （一）进程与线程

#### 1. 进程的概念与特征

进程是计算机上程序关于某个数据集上的一次运动活动、执行过程。是系统进行资源分配的一个基本单位。

进程是由多道程序的并发执行而引出的，与程序是截然不同的两个概念。进程有5个特征：
  - 动态性。进程是程序的一次执行过程，它有着创建、活动、暂停、停止、结束等过程，具有一定的生命周期，是动态地产生、变化和消亡。动态性是进程最基本地特征。
  - 结构性。每个进程都是由程序段、数据段、程序控制块（process control block， PCB）组成。并且PCB是进程存在的唯一标识。
  - 并发性。进程是由多道程序的并发执行而产生的。并发性是指多个进程实体同时存在于内存中，能在一段时间内同时运行。这是进程的重要特征，也是操作系统的重要特征。
  - 独立性。指进程实体是一个能独立运行、独立获得系统资源、独立接受调度的基本单位。
  - 异步性。进程按照各自独立的、不可预知的速度向前推进。

#### 2. 进程的状态与转换、控制
- 就绪态
- 运行态
- 结束态
- 阻塞态
- 创建态

进程控制的主要功能是对系统中所有的进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转化等功能。
在操作系统的低层，**进程控制的原语其实主要实现了三件事**：

1. 更新进程控制块PCB的信息
2. 将进程控制块PCB插入到合适的队列中
3. 回收和分配系统资源

#### 3. 进程的组织

进程由进程控制块、程序段、数据段三个部分组成

1. 进程控制块

主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息。

#### 4. 进程通信

管道、消息队列、共享内存、信号量、socket

备注：字符流处理的单元为2个字节的unicode字符，分别操作字符、字符数组或字符串，而字节流处理单元为1个字节。

#### 5. 线程

在进程是由多道程序的并发执行而引出的。为了更好地使多道程序并发执行，提高资源的利用率和系统的吞吐量就引入了线程。

引入此线程的目的是为了减少程序在并发执行过程中所付出的时空开销，提高操作系统的并发性能。

线程由线程ID、程序计数器、寄存器集合和堆栈组成。线程是一个轻量的实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。

1. 线程的实现方式

线程的实现有两种方式：用户级线程和内核级线程（内核支持的线程）。

在用户级线程中，有关线程管理（线程的创建、撤销和切换等）的所有工作都应有应用程序完成，内核意识不到线程的存在。用用程序可以通过使用线程库设计成多线程程序。

在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每一个线程维护上下文信息，调度也在内核基于线程架构的基础上完成。

[参考——线程的3种实现方式--内核级线程, 用户级线程和混合型线程](https://blog.csdn.net/gatieme/article/details/51892437)


#### 6. 补充：协程（微线程）

[参考——协程](https://www.jianshu.com/p/6dde7f92951e)

协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。

协程不是进程也不是线程，而是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。所以说，协程与进程、线程相比并不是一个维度的概念。

一个进程可以包含多个线程，一个线程也可以包含多个协程。简单来说，一个线程内可以由多个这样的特殊函数在运行，但是有一点必须明确的是，一个线程的多个协程的运行是串行的。如果是多核CPU，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内协程却绝对是串行的，无论CPU有多少个核。毕竟协程虽然是一个特殊的函数，但仍然是一个函数。一个线程内可以运行多个函数，但这些函数都是串行运行的。当一个协程运行时，其它协程必须挂起。

1. 进程、线程、协程的对比

- 协程既不是进程也不是线程，协程仅仅是一个特殊的函数，协程它进程和进程不是一个维度的。
- 一个进程可以包含多个线程，一个线程可以包含多个协程。
- 一个线程内的多个协程虽然可以切换，但是多个协程是串行执行的，只能在一个线程内运行，没法利用CPU多核能力。
- 协程与进程一样，切换是存在上下文切换问题的。

2. 上下文切换

进程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户是无感知的。进程的切换内容包括页全局目录、内核栈、硬件上下文，切换内容保存在内存中。进程切换过程是由“用户态到内核态到用户态”的方式，切换效率低。

线程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户无感知。线程的切换内容包括内核栈和硬件上下文。线程切换内容保存在内核栈中。线程切换过程是由“用户态到内核态到用户态”， 切换效率中等。

协程的切换者是用户（编程者或应用程序），切换时机是用户自己的程序所决定的。协程的切换内容是硬件上下文，切换内存保存在用户自己的变量（用户栈或堆）中。协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高。


### （二）处理机调度

在多道程序系统中，进程的数量往往多于处理机的个数，因此进程争用处理机的情况在所难免。处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。

处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。

#### 1. 调度的层次

1. **高级调度（作业调度）：**主要任务是按照一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给它（们）分配内存、输入/输出设备等必要的的资源，并建立相应的进程，以使它（们）获得竞争处理机的权利。
2. **中级调度（内存调度）：**将那些暂时不能运行的进程调度到外存等待。把此时进程的状态称为挂起。
3. **低级调度（进程调度）：**主要任务是按照某种方法和策略从就绪就绪队列中选取一个进程，将处理机分配给它。

由上述介绍可知，高级调度是进程活动的准备工作，次数少；中级调度将不使用的进程暂时挂起，次数略多；低级调度最基本，频率最高。

#### 2. 进程调度方式

1. 非剥夺调度方式，又称非抢占式。
2. 剥夺调度方式，又称抢占式。主要有优先级调度算法、短进程优先调度算法、时间片轮转调度算法等

#### 3. 经典的调度算法

1. 先来先服务（FCFS）调度算法

	既可用于作业调度，也可用于进程调度。属于非剥夺调度方式。

2. 短作业优先（SJF）调度算法

	从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。
	
	该算法对长作业不利，可能会导致长作业长期分配不到处理机而出现“饥饿”现象。该算法未考虑到作业的紧迫程度。
	
3. 优先级调度算法

	顾名思义，优先处理优先级高的作业或者进程。又分为剥夺式与非剥夺式、静态优先级与动态优先级。
	
	一般来说，优先级的设置可以参考以下的原则：
	- 系统进程 > 用户进程
	- 交互型进程 > 非交互型进程
	- I/O型进程 > 计算型进程

4. 高响应比优先调度算法

	响应比 = （等待时间 + 要求服务时间） / 要求服务时间 = 1 + （等待时间 / 要求服务时间）
	
5. 时间片轮转调度算法

	主要用于分时系统。时间片的大小对系统性能的影很大。
	
6. 多级反馈队列调度算法

	此算法是时间片轮转和优先级调度算法的结合
	
## 三、内存管理

### （一）内存管理的概念

1. 为什么要进行内存管理
2. 页式管理中每个页表项大小的下限如何决定？
3. 多级页表解决了什么问题？又带来了什么问题？

内存管理的功能：

1. 内存空间的分配和回收
2. 地址转换
3. 内存空间的扩充
4. 存储保护

#### 1. 内存管理的基本原理和要求

1. 进程运行的基本原理和要求

  1. 程序的装入和链接
    编译 -> 链接 -> 装入
	
	链接分为静态链接、装入时动态链接、运行时动态链接
	
  2. 逻辑地址空间与物理地址空间

  3. 内存保护


#### 2. 覆盖与交换

1. 覆盖的基本思想是：由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可把用户空间分成一个固定区和若干覆盖区。现代操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史。

2. 交换（对换）的基本思想是：把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存中，把内存空间腾出来，这一过程又叫做换出；把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称换入。

交换技术主要在不同进程（或作业）之间进行的，而覆盖则用于同一个程序或进程中。


#### 3. 连续分配管理方式

首先，连续分配管理方式是指一个用户程序分配一个**连续**的内存空间。连续分配方式主要包括：单一连续分配、固定分区分配和动态分区分配。

1. **单一连续分配**：内存在这种方式下分为系统区和用户区。系统区仅供操作系统使用，通常在低地址部分。用户区为用户提供的、出系统区之外的内存空间。这种方式无须进行内存保护。因为内存永远只有一道程序，因此肯定不会因为访问越界而干扰其他程序。

2. **固定分区分配**：这是一种最简单的多道程序存储管理方式，它将用户内存划分为若干个固定大小的区域，每个分区只装入一道作业。有两种划分方法：分区大小相等、分区大小不等。

3. **动态分区分配**：又称可变分区分配。这种分区方法不预先划分内存，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。

  在进程装入或换入主存时，若内存中有多个足够大的内存空闲块，则操作系统必须确定分配哪一块给进程使用。这就涉及到动态分区的分配策略。主要考虑下列4种算法：
  
  1. **首次适应算法**：不仅是最简单的，而去通常情况下也是最好和最快的。
  2. **最佳适应算法**：
  3. **最坏适应算法**：又称最大适应算法
  4. **邻近适应算法**：又称循环首次适应算法

#### 4. 非连续分配管理方式

非连续分配管理方式根据分区的大小是否固定，分为分页存储管理方式和分段存储管理方式。

1. **分页存储管理方式**

  在分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行，分为**基本分页存储管理方式**和**请求分页存储管理方式**
  
  **<番外**：
  
  在**基本分页存储管理方式**中 ：不具备页面对换功能，不支持虚拟存储器功能，在调度作业运行时 ,必须将它的所有页面一次调入内存 ,若内存没有足够的块, 则作业等待的这种分页管理方式被称为纯分页或基本分页存储管理方式.
  
  而**请求分页管理方式**是支持虚拟存储的,具备了页面的对换功能.调度作业时 是将它的 一部分（而不是全部） 放入内存.当发现页面缺少时 会发出一个缺页请求 从外存调用页面文件进入内存.
  
  基于以上所述：基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。
  
  **end>**
  
  多级页表的目的在于建立索引，以便不用浪费主存空间去存储无用的页表项，也不用盲目的顺序式查找页表项。  

### （二）虚拟存储器（请求分页）

#### 3. 页面置换算法

1. **最佳置换算法**

 淘汰以后不会使用的页，易知该算法无法实现。
 
2. **先进先出（FIFO）页面置换算法**

  优先淘汰最早进入内存的页面，即在内存中驻留时间最久的页面。使用队列即可实现。

3. **最近最久未使用（Last Resent Used， LRU）置换算法**

4. **时钟置换算法**

#### 4. 页面分配策略

#### 5. 抖动

刚刚换入的页面马上又要换出主存，刚刚换出的页面马上又要换入主存。这种频繁的页面调度行为称为**抖动或颠簸**。

抖动的主要原因是，某个进程频繁访问的页面数目高于可用的物理页数目。