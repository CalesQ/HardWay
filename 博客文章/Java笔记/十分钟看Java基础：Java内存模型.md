说明：本文的大部分内容参考和摘取了《Java并发编程艺术》这本书，对我来说也相当于做笔记吧。

## 一、 Java内存模型的基础

### 1. 总述
**内存模型，我简单的理解就是Java在运行过程中的JVM对内存进行一系列操作的框架或者了流程**（仅代表个人观点）。

在并发编程中，主要需要处理两个关键的问题：**线程之间的通信**、**线程之间的同步**

### 2. 简介

说到Java的内存模型，就不得不和计算机的内存模型相联系起来了。

1. CPU执行过程

大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道，而计算机上面的临时数据，是储存在主存中的。

计算机内存包括**高速缓存**和**主存**。

我们知道CPU执行指令的速度比从主存读取数据和向主存写入数据快很多，所以为了高效利用CPU，CPU增加了高速缓存(cache)来匹配CPU的执行速度，最终程序的执行过程如下：

 - 首先会将数据从主存中复制一份到CPU的高速缓存中

 - 当CPU执行计算的时候就可以直接从高速缓存中读取数据和写入数据

 - 当运算结束后，再将高速缓存的数据更新到主存中

（下图来源于电子书）
![](十分钟看Java基础：Java内存模型_files/1.jpg)

2. Java执行过程（抽象结构）

所以，在Java内存模型中，也是类似的结构，如下图：
（下图来源于电子书）
![](十分钟看Java基础：Java内存模型_files/2.jpg)

所以可以知道：

**Java内存模型(Java Memory Model，JMM)**即是Java语言对前面提到的——计算机解决多线程场景下的一个主存操作规范的遵循，JMM规定了所有的变量都存储在主存中，每个线程都有自己的工作区，线程将使用到的变量从主存中复制一份到自己的工作区，线程对变量的所有操作(读取、赋值等)都必须在工作区，不同的线程也无法直接访问对方工作区，线程之间的消息传递都需要通过主存来完成。可以把这里主存类比成计算机内存模型中的主存，工作区类比成计算机内存模型中的高速缓存。

然后通过Java内存模型，在多线程场景下访问主存保证**原子性**、**可见性**、**有序性**。


## 二、 进一步了解Java内存模型

### (一) 重排序（为了优化、提升性能）

首先我们要知道重排序分三种类型：编译器优化重排序、指令级并行重排序、内存系统重排序。下面先简单说一下这三种不同维度的重排序：

 - **编译器优化重排序**：这个是编译器在不改变单线程语义的前提下，可以重新安排语句的执行顺序。
 - **指令级并行重排序**：多条指令重叠执行。
 - **内存系统重排序**：对内存的加载和存储的顺序进行重新排序。

从Java源码到最后的指令序列的执行，都会经历上述的三种不同维度的重排序。

我们现在可以知道的是，重排序很直接的目的是提高计算机的性能，加快速度，但是有利也有弊。不对它进行一些特殊的处理，可能它带来的结果就不是我们期望的那样。
因此，我们就引出的下面的这些内容。

1. **内存屏障**
	
	为了保证内存的可见性，Java编译器在指令序列的适当位置会插入**内存屏障指令**，来禁止特定类型的处理器重排序。JMM 把内存屏障指令分成了 **LoadLoad、LoadStore、StoreStore、StoreLoad** 这4种。想要了解这四种内存屏障指令的具体内容的小伙伴，可以花点时间去看看。
	
2. **happens-before**

	用于阐述操作之间的内存可见性。在JMM中，如果一个操作的执行结果需要对另一个操作可见（简单的说就是有影响吧），那么就会在两个操作之间必须存在一个happens-before的关系。
	
3. **as-if-serial**: 不管怎么重排序，单线程程序的执行结果不能被改变

### （二）顺序一致性内存模型

这是一个**理论参考模型**，在具体设计的时候会以此作为参考。它的两大特性：

1. 一个线程中的所有线程操作必须按照程序的顺序来执行。（好像和重排序有些冲突了，不过这也是参考。毕竟有了参考就好下手了不是。）
2. （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性模型中，每个操作都必须原子执行且立刻对所有线程可见。


## 三、 关键词的内存语义
### （一）volatile
**volatile原理**

 - 由有volatile修饰的变量汇编代码中会多出**Lock**前缀的指令。
  1. Lock前缀指令会引起处理器缓存回写到内存。
  2. 一个处理器的缓存回写到内存会导致其他处理器的缓存无效。

**volatile语义的实现**
	
 - 使用到了上述的内存屏障，具体的去看书哦

### （二） 锁

从某种角度上看，也和 **volatile** 是一样的 —— 获取时获取最新，更改时刷新主存。

**锁的实现**

锁的实现涉及到的内容有点多，主要是CAS、AQS等知识。因为本篇的重点是Java的内存模型，所以就不再细说了。
后面应该还会专门写一篇关于Lock的文章，有兴趣的小伙伴可以去了解一下。
	
	
## 写在最后

文章的内容到这里就结束了，感谢你的观看。

如果你觉得文章对你来说有收获的话，可以给我点赞，这是对我坚持下去最大的激励。

如果想要获取最新发布的文章，不妨点个关注哦。